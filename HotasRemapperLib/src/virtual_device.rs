use std::ffi::c_char;

use swift_rs::swift;
use swift_rs::SwiftArg;

use crate::pointer_wrapper_swift;
use crate::ConnectionStatusCallback;
use crate::ConnectionType;

pointer_wrapper_swift!(
    ConnectionStatusCallbackWrapper,
    unsafe extern "C" fn(bool)
);

pointer_wrapper_swift!(RawPointerWrapper, *const c_char);

swift!(fn OpenBluetoothLib(
    virtual_device_callback: ConnectionStatusCallbackWrapper,
    rfcomm_channel_callback: ConnectionStatusCallbackWrapper));
swift!(fn SendDataViaBluetooth(buffer: RawPointerWrapper, length: u32));
swift!(fn CloseBluetoothLib());

static mut CONNECTION_STATUS_CALLBACK: Option<ConnectionStatusCallback> = None;

/// This device is connected via Bluetooth, responsible for forwarding HID
/// keyboard input events generated by us.
pub(crate) struct VirtualDevice {
    input_report: KeyboardInputReport,
}

impl VirtualDevice {
    pub fn new(connection_status_callback: ConnectionStatusCallback) -> Self {
        // Safe because we assume single thread.
        unsafe {
            CONNECTION_STATUS_CALLBACK = Some(connection_status_callback)
        };
        // Safe because we are just passing in a static function.
        unsafe {
            OpenBluetoothLib(
                ConnectionStatusCallbackWrapper(
                    UpdateVirtualDeviceConnectionStatus,
                ),
                ConnectionStatusCallbackWrapper(
                    UpdateRFCOMMChannelConnectionStatus,
                ),
            )
        };
        Self {
            input_report: KeyboardInputReport::new(),
        }
    }

    pub fn send_output_with_new_key_event(
        &mut self,
        key_code: c_char,
        is_pressed: bool,
    ) {
        self.input_report.update_key_state(key_code, is_pressed);
        let report = self.input_report.report();
        // Safe because the input report outlives this call.
        unsafe {
            SendDataViaBluetooth(
                RawPointerWrapper(report.as_ptr()),
                report.len() as u32,
            );
        }
    }
}

impl Drop for VirtualDevice {
    fn drop(&mut self) {
        // Safe because we assume single thread.
        unsafe { CONNECTION_STATUS_CALLBACK = None };
        // Trivially safe.
        unsafe { CloseBluetoothLib() };
    }
}

#[no_mangle]
pub unsafe extern "C" fn UpdateVirtualDeviceConnectionStatus(
    is_connected: bool,
) {
    if let Some(callback) = CONNECTION_STATUS_CALLBACK {
        callback(ConnectionType::VirtualDevice, is_connected);
    }
}

#[no_mangle]
pub unsafe extern "C" fn UpdateRFCOMMChannelConnectionStatus(
    is_connected: bool,
) {
    if let Some(callback) = CONNECTION_STATUS_CALLBACK {
        callback(ConnectionType::RFCOMMChannel, is_connected);
    }
}

enum ReportField {
    _ModifierKeyStates = 0,
    KeyStatesBegin = 1,
    KeyStatesEndExclusive = 7,
}

const REPORT_LENGTH: usize = ReportField::KeyStatesEndExclusive as usize;

struct KeyboardInputReport {
    report: [c_char; REPORT_LENGTH],
}

impl KeyboardInputReport {
    pub fn new() -> Self {
        Self {
            report: [0; REPORT_LENGTH],
        }
    }

    pub fn report(&self) -> &[c_char; REPORT_LENGTH] {
        &self.report
    }

    pub fn update_key_state(&mut self, key_code: c_char, is_pressed: bool) {
        // If this key has been pressed previously, remove it from the report if
        // it is now released.
        if let Some(key_state) = self.find_key_state(key_code) {
            if !is_pressed {
                *key_state = 0x00;
            }
            return;
        }
        // If a new key is pressed, find an available slot for it.
        if is_pressed {
            match self.find_key_state(0x00) {
                Some(key_state) => *key_state = key_code,
                None => println!(
                    "No available slot for key press (keycode: {})",
                    key_code
                ),
            }
        }
    }

    fn find_key_state(&mut self, key_code: c_char) -> Option<&mut c_char> {
        for index in ReportField::KeyStatesBegin as usize
            ..ReportField::KeyStatesEndExclusive as usize
        {
            if self.report[index] == key_code {
                return Some(&mut self.report[index]);
            }
        }
        None
    }
}
