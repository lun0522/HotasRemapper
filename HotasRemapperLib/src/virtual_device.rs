use std::ffi::c_char;

use swift_rs::swift;
use swift_rs::SwiftArg;

use crate::virtual_device_output::VirtualDeviceOutput;
use crate::ConnectionStatusCallback;
use crate::DeviceType;

pub(crate) type VirtualDeviceConnectionStatusCallback =
    unsafe extern "C" fn(bool);

pub struct BluetoothLibCallback(pub VirtualDeviceConnectionStatusCallback);

impl<'a> SwiftArg<'a> for BluetoothLibCallback {
    type ArgType = VirtualDeviceConnectionStatusCallback;

    unsafe fn as_arg(&'a self) -> Self::ArgType {
        self.0
    }
}

pub struct RawPointer(*const c_char);

impl<'a> SwiftArg<'a> for RawPointer {
    type ArgType = *const c_char;

    unsafe fn as_arg(&'a self) -> Self::ArgType {
        self.0
    }
}

swift!(fn OpenBluetoothLib(callback: BluetoothLibCallback));
swift!(fn SendDataViaBluetooth(buffer: RawPointer, length: u32));
swift!(fn CloseBluetoothLib());

static mut CONNECTION_STATUS_CALLBACK: Option<ConnectionStatusCallback> = None;

/// This device is connected via Bluetooth, responsible for forwarding HID input
/// events generated by us.
pub(crate) struct VirtualDevice {
    device_output: VirtualDeviceOutput,
}

impl VirtualDevice {
    pub fn new(connection_status_callback: ConnectionStatusCallback) -> Self {
        // Safe because we assume single thread.
        unsafe {
            CONNECTION_STATUS_CALLBACK = Some(connection_status_callback)
        };
        // Safe because we are just passing in a static function.
        unsafe {
            OpenBluetoothLib(BluetoothLibCallback(
                UpdateVirtualDeviceConnectionStatus,
            ))
        };
        Self {
            device_output: VirtualDeviceOutput::new(),
        }
    }

    pub fn send_output_with_new_key_event(
        &mut self,
        key_code: c_char,
        is_pressed: bool,
    ) {
        self.device_output.update_key_state(key_code, is_pressed);
        let report = self.device_output.report();
        // Safe because the input report outlives this call.
        unsafe {
            SendDataViaBluetooth(
                RawPointer(report.as_ptr()),
                report.len() as u32,
            );
        }
    }
}

impl Drop for VirtualDevice {
    fn drop(&mut self) {
        // Safe because we assume single thread.
        unsafe { CONNECTION_STATUS_CALLBACK = None };
        // Trivially safe.
        unsafe { CloseBluetoothLib() };
    }
}

#[no_mangle]
pub unsafe extern "C" fn UpdateVirtualDeviceConnectionStatus(
    is_connected: bool,
) {
    if let Some(callback) = CONNECTION_STATUS_CALLBACK {
        callback(DeviceType::VirtualDevice, is_connected);
    }
}
